# Gamma Structure

## Files and Folders
Currently Gamma files and folders are located in one place which are all under the gamma folder.
The paths in this section are relative to the Gamma folder.

### Tree view of Gamma files and folders:-
```
.
├── bin
│   ├── com.editor.gamma.desktop.bak
│   ├── gamma
│   └── icon.svg
├── config.py
├── docs
│   └── *
├── gamma.py
├── gtksourceview_styles
│   └── *.xml
├── plugins
│   └── plugins_manager.py
├── README.md
├── setup.sh
├── signal_handler.py
├── sourceview_manager.py
├── style
│   └── *.css
└── ui
    └── builder.ui
```

In the above tree view I excluded plugins folders which are located in `./plugins` alongside with `plugins_manager.py`.

### ./gamma.py
Is the entry point to Gamma. For python apps/files that need to use Gtk, the `gi` must be imported which is the
GObject Introspection bindings for python. Versions of Gtk and GtkSource should be specified. Gamma depends on Gtk version 3,
but for GtkSource, Gamma can work with GtkSource version `3.0`. It is better to use version `4` for GtkSource but for some
systems the higher version of GtkSource they can get is `3.0`. Anyway, see the imports section of gamma.py below:-
```
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GtkSource', "4") # or 3.0 <- '.0' is important for version 3
from gi.repository import GLib, Gio, Gtk, Gdk, GtkSource, GObject
```

They are not all used in gamma.py, must be cleaned up in future. For your plugin, you only import a library only
when you use it in your code. Literally, if you do not have for example `Gdk.something` in your code, then do not
import Gdk. Most likely you need to import Gtk and GtkSource.

The `application_id="com.editor.gamma"` is the name of Gamma application which is good practice for Gnome/XWindow to
have unique name for the app. The Gamma icon is named `com.editor.gamma.svg` and it is placed in `~/.icons/` folder
after running `./setup.sh`.

In order to use GtkSource, you need to register GtkSource once in the application `GObject.type_register(GtkSource.View)`.

Notice that `gamma.py` inherits `Gtk.Application` and implements some methods such as `do_startup` and `do_activate`.
Read about Gtk and PyGObject for more information on `Gtk.Application`.

The first thing `gamma.py` does (important to plugins perspective) is to have a reference of `config.config_paths_and_settings`
which is a dictionary contains paths and settings of Gamma:
```
config_paths_and_settings = {
	"ui-path": ...
	"style-path": ...
	"style-scheme": ...
	"show_grid": ...
	"font-family": ...
	"font-size": ...
	....
}
```

After that `load_builder` is called which defines the `builder` (builder is the object responsible of translating .ui xml
files "widgets design/layout" to be in the gtk objects form) see glade. The line
`self.builder.add_from_file(self.config["ui-path"])` loads .ui file, its path is in config file. The default .ui file
is `./ui/builder.ui`. From `builder` we can access the gtk widgets loaded from .ui file by calling
`builder.get_object("widget_id")`. The widgets ids are set in the .xml/.ui file. Note that the extension of the ui
file can be any, ui files are in xml formats, usually are made by Glade. In future, we might change all .ui/xml extensions
to `.glade` which is easier when open them in Glade, and also the Glade can store their names and reopen them faster.
It is good to give some credits to Glade for the awesome project by naming ui files' extensions generated by Glade to `.glade`.


In `do_activate` method, we gets the window widget from the `builder` which contains Gamma layout. We set the application
property to self (which is Gtk.Application) and before calling `window.show_all()` to show the window, we need to 
load plugins and call their `activate` functions by calling `self.plugins_manager.load_plugins()`.
In `plugins_manager.py`, you can comment out plugins in `plugin_list` array. After this line, each plugin is loaded,
and the `activate` method of each plugin is called. In `activate` method we usually set the signal handlers which 
connect gtk widgets signals to a plugin method. The actuall connecting happens in `set_handlers` method in `gamma.py`
where `self.builder.connect_signals(self.signal_handler.handlers)` is the method in `builder` to connect signals.
Notice that `signal_handler.handlers` is just an empty object which helps you to bind any property such as:
```
handlers.on_window_key_press_event = self.on_window_key_press_event
```
The left side `on_window_key_press_event` is the actual signal from the ui file. The right side is our method that
handles the event. Each signal in Gtk has specific signature, so read Gtk or PyGObject docs for each widget signal.
		

Before opening the window we need to pass any args that the user typed in the terminal to `files_manager.openfile`
plugin. This is useful to open files from command line with Gamma. The `./bin/gamma` bash file sets/exports
`GAMMA_OPEN_FILE` with all args. See the `gamma.py` code below which gets the environment variable `GAMMA_OPEN_FILE`
and pass the filenames (assumingly) to `open_files_from_args` method.
```
filenames = os.getenv('GAMMA_OPEN_FILE')
self.plugins_manager.plugins["files_manager.openfile"].open_files_from_args(filenames)
```

Finally, we show the window. Notice that `gamma.py` passes itself (as an app or a Gtk.Application)
reference to `PluginsManager`, and `PluginsManager` passes the `app`
to each loaded plugin. Therefore, each plugin, has a reference to `app` which is the starting point for a plugin to access
any of (window, config, builder, plugins_manager, signal_handler, and sourceview_manager).  



### ./config.py
Contains configuration for Gamma such as ui, style, and style-scheme paths. Also, some universal configurations
such as the font type and font size.


### ./plugins/plugins_manager.py
Is responsible for initating plugins. by using "importlib" the plugins loaded and included
to Gamma. It goes through "plugin_list" to get exact name
of the plugin package. For each plugin, plugin module is 
included, the app reference is passed to plugin, and the
"activate" method of a plugin is called. "activate" is plugin init,
so do not use plugins' `__init__` for complex operation. The
plugins' `__init__` must only include direct references assignments
(i.e. self.builder = app.builder). Other than these assignments,
plugins activate must be your method for initializing you plugin.
The reason for this design is to know which plugin must be eager
and which must be lazy plugin. Simply, if your activate method 
is not implemented (i.e. def activate(self): pass), then the plugin 
is lazy plugin.

Lazy plugins strategy is not implemented yet. But in future we will have
lazy plugins that are not loaded in Gamma startup. Instead, they will be 
loaded only when needed. 


### ./signal_handler.py
Is the class that manage signal handlers. `Handlers` is an object for mapping signal names with 
callback methods references. You can mapp ui signals by simply assign as following:
`handlers.on_some_ui_event = some_callback_method`. `set_handlers` method is the convention
way when need to map ui signals to callback functions. It is good to have the same method name
in your plugin when need connect ui signals to your plugin's methods.

SignalHandler sets the main signals such as key press.
```
def set_handlers(self):
	self.handlers.on_window_key_press_event = self.on_window_key_press_event
	self.handlers.resizeBodySide = self.resizeBodySide
	self.handlers.resizeHeaderSide = self.resizeHeaderSide
```

You should not map `on_window_key_press_event` to your plugin.
`on_window_key_press_event` function will help you by getting the keyval_name("e", "space", ..)
and other modifiers like ctrl, alt, and shift. Simply uncomment:
``` 
self.signal_handler.key_bindings_to_plugins.append(self)   or
self.signal_handler.any_key_press_to_plugins.append(self)
```
and then check what key binding you need such as
```
if alt and ctrl and keyval_name == "m":
	...
```
the above "if" is checking whether alt and ctrl are hold when pressed the "m" key (i.e. `<Ctrl><Alt>+m`)

#### key_bindings_to_plugins vs any_key_press_to_plugins
`key_bindings_to_plugins` for key bindings only (`<Ctrl>+a`)
However `any_key_press_to_plugins` will call your `key_bindings`
method for any key press! Sometimes is needed but usually
for shortcuts use `key_bindings_to_plugins`



