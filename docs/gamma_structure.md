# Gamma Structure

## Files and Folders
Currently Gamma files and folders are located in one place which are all under the gamma folder.
The paths in this section are relative to the Gamma folder.

### Tree view of Gamma files and folders:-
```
.
├── bin
│   ├── com.editor.gamma.desktop.bak
│   ├── gamma
│   └── icon.svg
├── config.py
├── docs
│   └── *
├── gamma.py
├── gtksourceview_styles
│   └── *.xml
├── plugins
│   └── plugins_manager.py
├── README.md
├── setup.sh
├── signal_handler.py
├── sourceview_manager.py
├── style
│   └── *.css
└── ui
    └── builder.ui
```

In the above tree view I excluded plugins folders which are located in `./plugins` alongside with `plugins_manager.py`.

### ./gamma.py
Is the entry point to Gamma. For python apps/files that need to use Gtk, the `gi` must be imported which is the
GObject Introspection bindings for python. Versions of Gtk and GtkSource should be specified. Gamma depends on Gtk version 3,
but for GtkSource, Gamma can work with GtkSource version `3.0`. It is better to use version `4` for GtkSource but for some
systems the higher version of GtkSource they can get is `3.0`. Anyway, see the imports section of gamma.py below:-
```
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('GtkSource', "4") # or 3.0 <- '.0' is important for version 3
from gi.repository import GLib, Gio, Gtk, Gdk, GtkSource, GObject
```

They are not all used in gamma.py, must be cleaned up in future. For your plugin, you only import a library only
when you use it in your code. Literally, if you do not have for example `Gdk.something` in your code, then do not
import Gdk. Most likely you need to import Gtk and GtkSource.

The `application_id="com.editor.gamma"` is the name of Gamma application which is good practice for Gnome/XWindow to
have unique name for the app. The Gamma icon is named `com.editor.gamma.svg` and it is placed in `~/.icons/` folder
after running `./setup.sh`.

In order to use GtkSource, you need to register GtkSource once in the application `GObject.type_register(GtkSource.View)`.

Notice that `gamma.py` inherits `Gtk.Application` and implements some methods such as `do_startup` and `do_activate`.
Read about Gtk and PyGObject for more information on `Gtk.Application`.

The first thing `gamma.py` does (important to plugins perspective) is to have a reference of `config.config_paths_and_settings`
which is a dictionary contains paths and settings of Gamma:
```
config_paths_and_settings = {
	"ui-path": ...
	"style-path": ...
	"style-scheme": ...
	"show_grid": ...
	"font-family": ...
	"font-size": ...
	....
}
```

After that `load_builder` is called which defines the `builder` (builder is the object responsible of translating .ui xml
files "widgets design/layout" to be in the gtk objects form) see glade. The line
`self.builder.add_from_file(self.config["ui-path"])` loads .ui file, its path is in config file. The default .ui file
is `./ui/builder.ui`. From `builder` we can access the gtk widgets loaded from .ui file by calling
`builder.get_object("widget_id")`. The widgets ids are set in the .xml/.ui file. Note that the extension of the ui
file can be any, ui files are in xml formats, usually are made by Glade. In future, we might change all .ui/xml extensions
to `.glade` which is easier when open them in Glade, and also the Glade can store their names and reopen them faster.
It is good to give some credits to Glade for the awesome project by naming ui files' extensions generated by Glade to `.glade`.


In `do_activate` method, we gets the window widget from the `builder` which contains Gamma layout. We set the application
property to self (which is Gtk.Application) and before calling `window.show_all()` to show the window, we need to 
load plugins and call their `activate` functions by calling `self.plugins_manager.load_plugins()`.
In `plugins_manager.py`, you can comment out plugins in `plugin_list` array. After this line, each plugin is loaded,
and the `activate` method of each plugin is called. In `activate` method we usually set the signal handlers which 
connect gtk widgets signals to a plugin method. The actuall connecting happens in `set_handlers` method in `gamma.py`
where `self.builder.connect_signals(self.signal_handler.handlers)` is the method in `builder` to connect signals.
Notice that `signal_handler.handlers` is just an empty object which helps you to bind any property such as:
```
handlers.on_window_key_press_event = self.on_window_key_press_event
```
The left side `on_window_key_press_event` is the actual signal from the ui file. The right side is our method that
handles the event. Each signal in Gtk has specific signature, so read Gtk or PyGObject docs for each widget signal.
		

Before opening the window we need to pass any args that the user typed in the terminal to `files_manager.openfile`
plugin. This is useful to open files from command line with Gamma. The `./bin/gamma` bash file sets/exports
`GAMMA_OPEN_FILE` with all args. See the `gamma.py` code below which gets the environment variable `GAMMA_OPEN_FILE`
and pass the filenames (assumingly) to `open_files_from_args` method.
```
filenames = os.getenv('GAMMA_OPEN_FILE')
self.plugins_manager.plugins["files_manager.openfile"].open_files_from_args(filenames)
```

Finally, we show the window. Notice that `gamma.py` passes itself (as an app or a Gtk.Application)
reference to `PluginsManager`, and `PluginsManager` passes the `app`
to each loaded plugin. Therefore, each plugin, has a reference to `app` which is the starting point for a plugin to access
any of (window, config, builder, plugins_manager, signal_handler, and sourceview_manager).  



### ./config.py
Contains configuration for Gamma such as ui, style, and style-scheme paths. Also, some universal configurations
such as the font type and font size.


### ./plugins/plugins_manager.py
Is responsible for initating plugins by using "importlib" the plugins loaded and included
to Gamma. It goes through "plugin_list" to get exact name
of the plugin package. For each plugin, plugin module is 
included, the app reference is passed to plugin, and the
`activate` method of a plugin is called. `activate` is plugin init,
so do not use plugins' `__init__` for complex operation. The
plugins' `__init__` must only include direct references assignments
(i.e. `self.builder = app.builder`). Other than these assignments,
plugins `activate` must be your method for initializing you plugin.
The reason for this design is to know which plugin must be eager
and which must be lazy plugin. Simply, if your `activate` method 
is not implemented (i.e. `def activate(self): pass`), then the plugin 
is lazy plugin.

Lazy plugins strategy is not implemented yet. But in future we will have
lazy plugins that are not loaded in Gamma startup. Instead, they will be 
loaded only when needed. 


All plugins (including your future plugin) are placed in `./plugins` folder.
The `PluginsManager` has two properties:-
*	self.plugins = {}
*	self.plugins_array = []

They all store plugins references. The `plugins` dictionary is useful to get a pluign by its name.
The `plugins_array` is useful to loop through all plugins. Of course, inside your plugin you can
access `plugins` or `plugins_array` through the `app` which is passed to your plugin. See below example:
```
class Plugin():
	def __init__(self, app):
		self.name = "my_plugin"
		self.app = app
		self.plugins = app.plugins_manager.plugins
	
	# somewhere in your code 
	self.plugins["search.search_in_file"].do_highlight("", self.buffer)
```
This gets the reference of the `search_in_file` plugin and calls the `do_highlight` method.
What happens if the user disable or replaced the `search_in_file` plugin?
It is a problem that we are going to solve in future. So, prepare for some changes.
The new idea would be something like:
```
self.THE("file_searcher", do_highlight, ("", self.buffer))
```
-	`THE` is a plugin that we are going to add in future
-	`file_searcher` is not a plugin name! it is a category name of any plugin do the search in file functionality
-	`do_highlight` function name
-	the rest are the parameters

Why this approach is better? It is better for two reasons
1.	If user replace the current `search_in_file` plugin with lets say `better_search` plugin,
	the `THE` is able to call the method of `better_search`.
2.	If user disable all search in file plugins (i.e. has no any search in file plugin)
	the `THE` simply can ignore the call. Therefore, you do not worry to change your code.
	You just assume there is a plugin under a category called `file_searcher`.
	
	



### ./signal_handler.py
Is the class that manage signal handlers. `Handlers` is an object for mapping signal names with 
callback methods references. You can mapp ui signals by simply assign as following:
`handlers.on_some_ui_event = some_callback_method`. `set_handlers` method is the convention
way when need to map ui signals to callback functions. It is good to have the same method name
in your plugin when need connect ui signals to your plugin's methods.

SignalHandler sets the main signals such as key press.
```
def set_handlers(self):
	self.handlers.on_window_key_press_event = self.on_window_key_press_event
	self.handlers.resizeBodySide = self.resizeBodySide
	self.handlers.resizeHeaderSide = self.resizeHeaderSide
```

You should not map `on_window_key_press_event` to your plugin.
`on_window_key_press_event` function will help you by getting the keyval_name("e", "space", ..)
and other modifiers like ctrl, alt, and shift. Simply uncomment:
``` 
self.signal_handler.key_bindings_to_plugins.append(self)   or
self.signal_handler.any_key_press_to_plugins.append(self)
```
and then check what key binding you need such as
```
if alt and ctrl and keyval_name == "m":
	...
```
the above "if" is checking whether alt and ctrl are hold when pressed the "m" key (i.e. `<Ctrl><Alt>+m`)

#### key_bindings_to_plugins vs any_key_press_to_plugins
`key_bindings_to_plugins` for key bindings only (`<Ctrl>+a`)
However `any_key_press_to_plugins` will call your `key_bindings`
method for any key press! Sometimes is needed but usually
for shortcuts use `key_bindings_to_plugins`


SignalHandler has two methods called `emit` and `connect`. These methods are useful for custom events for
plugins. For example, the `files_manager` `./plugins/files_manager/files_manager.py` emit a signal every 
time the open file is switched to another file (i.e. user clicked on a file in file lists). The signal is
emitted in this form 
```
self.signal_handler.emit("file-switched", self.current_file.source_view)
```
The name of the signal is `file-switched` and it passes the sourceview of the current just displayed file.

From another plaugin, we can connect/listen to this signal by calling
```
self.signal_handler.connect("file-switched", self.update_buffer)
```
This call must be in the `__init__` method of the plugin. It connects the signal `file-switched`
to a local method called `update_buffer`. The `update_buffer` method is as this:
```
def update_buffer(self, new_source):
	self.sourceview = new_source
	self.buffer = self.sourceview.get_buffer()
	self.new_search = True
```
The name and the body of the method is up to you, but the method signature should get the sourceview that is been passed by
the `files_manager`. This example is in `./plugins/find_and_replace/find_and_replace.py` file.



### ./sourceview_manager.py
Is responsible for sourceview related functions
-	get new source view
-	detect the language of the just openned file and set the langauge (i.e. C,Python,C++ ..)
-	update source map (mini map) to connect to a sourceview



